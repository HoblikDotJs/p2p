<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PeerJS — URL Auto-Connect File Transfer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Inter, system-ui, sans-serif; margin: 18px; max-width:900px; }
    .row { display:flex; gap:12px; margin-bottom:12px; align-items:center; }
    .col { flex:1; }
    button { padding:8px 12px; }
    .log { background:#111; color:#eee; padding:10px; height:200px; overflow:auto; font-family:monospace; white-space:pre-wrap; }
    .idbox { font-family: monospace; background:#f4f4f4; padding:6px; border-radius:4px; display:inline-block; }
    progress { width:100%; height:14px; }
    .small { font-size:0.9rem; color:#666; }
    .connected { color:green; font-weight:bold; }
    #dropzone { border:2px dashed #ccc; padding:12px; border-radius:6px; text-align:center; color:#666; }
  </style>
</head>
<body>
  <h1>PeerJS — Auto-URL File Transfer</h1>
  <p class="small">Open the page, copy the <b>Share link</b> and send it to the receiver. When they open it, they'll connect automatically and can receive files.</p>

  <div class="row">
    <div class="col">
      <div><b>My Peer ID</b> <span id="myId" class="idbox">...</span></div>
      <div style="margin-top:8px;">
        <button id="copyLinkBtn">Copy share link</button>
        <button id="regenBtn">Regenerate ID</button>
      </div>
    </div>
    <div class="col">
      <div><b>Share link</b></div>
      <div style="margin-top:6px;"><a id="shareLink" href="#" target="_blank">—</a></div>
    </div>
  </div>

  <h3>Send file</h3>
  <div class="row">
    <input type="file" id="fileInput" />
    <button id="sendBtn">Send file</button>
  </div>
  <div id="sendProgressWrap" style="display:none; margin-top:8px;">
    <div class="small">Send progress</div>
    <progress id="sendProgress" max="1" value="0"></progress>
    <div id="sendProgressText" class="small"></div>
  </div>

  <h3>Incoming files</h3>
  <div id="incomingList"></div>

  <h3>Status / Log</h3>
  <div id="status">starting...</div>
  <div class="log" id="log"></div>

  <!-- PeerJS -->
  <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
  <script>
  // --- Utilities & UI ---
  const logEl = document.getElementById('log');
  const statusEl = document.getElementById('status');
  function log(...args) {
    const div = document.createElement('div');
    div.textContent = args.join(' ');
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
    console.log(...args);
  }

  const myIdEl = document.getElementById('myId');
  const shareLinkEl = document.getElementById('shareLink');
  const copyLinkBtn = document.getElementById('copyLinkBtn');
  const regenBtn = document.getElementById('regenBtn');
  const fileInput = document.getElementById('fileInput');
  const sendBtn = document.getElementById('sendBtn');
  const sendProgressWrap = document.getElementById('sendProgressWrap');
  const sendProgress = document.getElementById('sendProgress');
  const sendProgressText = document.getElementById('sendProgressText');
  const incomingList = document.getElementById('incomingList');

  // chunk size (safe for browsers)
  const CHUNK_SIZE = 64 * 1024; // 64KB

  let peer = null;
  let conn = null; // PeerJS DataConnection (one connection at a time)
  let incomingFiles = {}; // id -> {name,size,received,chunks,progressEl}

  // parse ?id param (target id that this client should connect to)
  const url = new URL(window.location.href);
  const targetIdFromUrl = url.searchParams.get('id');

  // Start or (re)create peer
  function startPeer(optionalId) {
    if (peer) {
      try { peer.destroy(); } catch(e) { console.warn('destroy previous peer', e); }
      peer = null;
      conn = null;
      document.getElementById('status').innerText = 'restarting...';
    }

    // Create a new random Peer ID unless optionalId provided
    peer = optionalId ? new Peer(optionalId) : new Peer();

    peer.on('open', id => {
      myIdEl.innerText = id;
      const shareURL = `${location.origin}${location.pathname}?id=${id}`;
      shareLinkEl.href = shareURL;
      shareLinkEl.innerText = shareURL;
      statusEl.innerText = 'ready (id: ' + id + ')';
      log('Peer open:', id);

      // If the page was opened with ?id=someId and that id is NOT our id
      // then we should attempt to connect to that id (this is the receiver side).
      // If targetIdFromUrl equals our id (edge case when user clicked their own link), skip.
      if (targetIdFromUrl && targetIdFromUrl !== id) {
        log('Auto-connecting to target id from URL:', targetIdFromUrl);
        connectTo(targetIdFromUrl);
      }
    });

    peer.on('connection', c => {
      log('Incoming connection from', c.peer);
      // close existing connection if present
      if (conn && conn.open) {
        try { conn.close(); } catch(e) {}
      }
      setupConnection(c);
    });

    peer.on('error', err => {
      log('Peer error:', err);
      statusEl.innerText = 'peer error';
    });

    // convenience buttons
    copyLinkBtn.onclick = async () => {
      try {
        await navigator.clipboard.writeText(shareLinkEl.href);
        log('Share link copied to clipboard');
      } catch(e) {
        alert('Copy failed — copy manually: ' + shareLinkEl.href);
      }
    };

    regenBtn.onclick = () => {
      if (!confirm('Regenerate peer ID? Existing connections will be closed.')) return;
      startPeer(); // new random id
    };
  }

  function connectTo(remoteId) {
    if (!peer) return alert('Peer not ready');
    if (remoteId === myIdEl.innerText) { log('Refusing to connect to self'); return; }
    log('Connecting to', remoteId);
    const c = peer.connect(remoteId, { reliable: true });
    c.on('open', () => {
      log('Connected to', remoteId);
      setupConnection(c);
    });
    c.on('error', (e) => log('connect error', e));
  }

  // Setup DataConnection event handlers
  function setupConnection(c) {
    conn = c;
    statusEl.innerText = 'connected to ' + conn.peer;
    myIdEl.classList.add('connected');

    conn.on('data', async data => {
      // Data can be object (metadata) or ArrayBuffer/Uint8Array/Blob
      // Check for control messages first
      if (data && typeof data === 'object' && !(data instanceof ArrayBuffer) && !(data instanceof Uint8Array) && !(window.Blob && data instanceof Blob)) {
        // control object
        if (data.type === 'file-meta') {
          const id = data.id;
          incomingFiles[id] = { name: data.name, size: data.size, received: 0, chunks: [] };
          // UI
          const wrap = document.createElement('div');
          wrap.id = 'file-' + id;
          const title = document.createElement('div');
          title.textContent = `Incoming: ${data.name} (${data.size} bytes)`;
          const p = document.createElement('progress');
          p.max = data.size;
          p.value = 0;
          const t = document.createElement('div');
          t.className = 'small';
          t.textContent = '0 / ' + data.size;
          wrap.appendChild(title);
          wrap.appendChild(p);
          wrap.appendChild(t);
          incomingList.prepend(wrap);
          incomingFiles[id].progressEl = p;
          incomingFiles[id].textEl = t;
          log('[file] incoming meta', data.name, data.size, 'id', id);
        } else if (data.type === 'file-complete') {
          const id = data.id;
          const f = incomingFiles[id];
          if (!f) { log('[file] unknown complete', id); return; }
          // assemble
          log('[file] assembling', f.name);
          // convert chunk list (Uint8Array) to Blob parts
          const parts = f.chunks.map(u8 => u8.buffer ? new Uint8Array(u8).buffer : u8);
          const blob = new Blob(parts);
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = f.name;
          a.style.display = 'none';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          log('[file] received complete:', f.name);
          // cleanup UI
          const wrap = document.getElementById('file-' + id);
          if (wrap) wrap.querySelector('.small').textContent = `Downloaded ${f.size} bytes — saved as ${f.name}`;
          delete incomingFiles[id];
        } else {
          log('[data] object', data);
        }
        return;
      }

      // Binary chunk handling (ArrayBuffer / Uint8Array / Blob)
      if (data instanceof ArrayBuffer || data instanceof Uint8Array) {
        const u8 = data instanceof Uint8Array ? data : new Uint8Array(data);
        handleBinaryChunk(u8);
        return;
      }

      // Blob (async)
      if (window.Blob && data instanceof Blob) {
        const buf = await data.arrayBuffer();
        handleBinaryChunk(new Uint8Array(buf));
        return;
      }

      // fallback: unknown
      log('[data] unknown type', data);
    });

    conn.on('close', () => {
      log('[conn] closed');
      statusEl.innerText = 'idle';
      myIdEl.classList.remove('connected');
      conn = null;
    });

    conn.on('error', (e) => {
      log('[conn] error', e);
    });
  }

  function handleBinaryChunk(u8) {
    // place chunk into first known incoming file (same heuristic as earlier)
    const keys = Object.keys(incomingFiles);
    if (keys.length === 0) {
      log('[file] got chunk but no metadata known');
      return;
    }
    const id = keys[0];
    const f = incomingFiles[id];
    f.chunks.push(u8);
    f.received += u8.byteLength;
    if (f.progressEl) f.progressEl.value = f.received;
    if (f.textEl) f.textEl.textContent = `${f.received} / ${f.size}`;
    log(`[file] chunk received (${u8.byteLength} bytes). total ${f.received}/${f.size}`);
  }

  // --- Sending files ---
  sendBtn.addEventListener('click', async () => {
    if (!conn || conn.open === false) return alert('Not connected');
    const files = fileInput.files;
    if (!files || files.length === 0) return alert('Select a file first');
    const file = files[0];
    await sendFile(file);
  });

  // drag & drop to fileInput
  document.body.addEventListener('dragover', e => { e.preventDefault(); });
  document.body.addEventListener('drop', e => {
    e.preventDefault();
    if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length) {
      fileInput.files = e.dataTransfer.files;
      log('File selected via drop:', fileInput.files[0].name);
    }
  });

  async function sendFile(file) {
    if (!conn || conn.open === false) { alert('Not connected'); return; }
    const id = Math.random().toString(36).slice(2);
    // send metadata first
    conn.send({ type: 'file-meta', id, name: file.name, size: file.size });
    log('[file] sending meta', file.name, file.size, 'id', id);

    // prepare progress UI
    sendProgressWrap.style.display = 'block';
    sendProgress.max = file.size;
    sendProgress.value = 0;
    sendProgressText.textContent = `0 / ${file.size}`;

    // stream file by slicing (broad browser compatibility)
    const total = file.size;
    let offset = 0;
    while (offset < total) {
      const chunk = file.slice(offset, offset + CHUNK_SIZE);
      // read as ArrayBuffer
      const buf = await chunk.arrayBuffer();
      // send the ArrayBuffer
      try {
        conn.send(buf);
      } catch (e) {
        log('[file] send error', e);
        // try reconnect? For now abort
        alert('Send failed: ' + e);
        sendProgressText.textContent = 'Send failed';
        return;
      }
      offset += buf.byteLength;
      sendProgress.value = offset;
      sendProgressText.textContent = `${offset} / ${total}`;
      // simple backpressure: if connection's bufferedAmount is large, wait a tick
      // PeerJS DataConnection proxies RTCDataChannel underneath; it may expose bufferedAmount on conn._dc
      // We'll check both common locations if present.
      await maybeWaitForBuffer();
    }

    // finished -> tell receiver to assemble
    conn.send({ type: 'file-complete', id });
    log('[file] send complete', file.name);

    // hide progress after a short delay
    setTimeout(() => { sendProgressWrap.style.display = 'none'; sendProgress.value = 0; sendProgressText.textContent = ''; }, 1200);
  }

  // try to detect and wait for bufferedAmount to drop
  function maybeWaitForBuffer() {
    return new Promise(resolve => {
      try {
        const dc = conn && (conn._dc || conn._dataChannel || conn._channel || conn.peerConnection && conn.peerConnection._dataChannels && conn.peerConnection._dataChannels[0]);
        // fallback threshold in bytes
        const THRESH = 256 * 1024; // 256KB
        if (!dc || typeof dc.bufferedAmount === 'undefined') {
          // unknown underlying DC: just wait a tiny bit to avoid overwhelming
          return setTimeout(resolve, 8);
        }
        if (dc.bufferedAmount <= THRESH) return resolve();
        // wait for bufferedAmountLow event if present
        const onLow = () => {
          try { dc.removeEventListener && dc.removeEventListener('bufferedamountlow', onLow); } catch(e){}
          resolve();
        };
        if (dc.addEventListener) {
          try {
            dc.addEventListener('bufferedamountlow', onLow, { once: true });
            // ensure we set the threshold if supported
            if (typeof dc.bufferedAmountLowThreshold !== 'undefined') {
              dc.bufferedAmountLowThreshold = THRESH;
            }
            // but also use timeout fallback
            setTimeout(resolve, 2000);
          } catch (e) {
            setTimeout(resolve, 50);
          }
        } else {
          setTimeout(resolve, 50);
        }
      } catch (e) {
        setTimeout(resolve, 20);
      }
    });
  }

  // --- start ---
  startPeer(); // create random id on load
  </script>
</body>
</html>
